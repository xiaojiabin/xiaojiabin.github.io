<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>成功源于每天的积累</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/bin/assets/css/0.styles.9cb74ece.css" as="style"><link rel="preload" href="/bin/assets/js/app.b47fad0f.js" as="script"><link rel="preload" href="/bin/assets/js/2.22993a7e.js" as="script"><link rel="preload" href="/bin/assets/js/51.be01dce3.js" as="script"><link rel="prefetch" href="/bin/assets/js/10.12574e7b.js"><link rel="prefetch" href="/bin/assets/js/100.cfaa075d.js"><link rel="prefetch" href="/bin/assets/js/101.b90c64a8.js"><link rel="prefetch" href="/bin/assets/js/102.072791a9.js"><link rel="prefetch" href="/bin/assets/js/103.ff598b1e.js"><link rel="prefetch" href="/bin/assets/js/104.490e1293.js"><link rel="prefetch" href="/bin/assets/js/105.3e805b17.js"><link rel="prefetch" href="/bin/assets/js/106.03295f1f.js"><link rel="prefetch" href="/bin/assets/js/107.8027343c.js"><link rel="prefetch" href="/bin/assets/js/108.4e08bdd0.js"><link rel="prefetch" href="/bin/assets/js/109.2100f102.js"><link rel="prefetch" href="/bin/assets/js/11.7527fc87.js"><link rel="prefetch" href="/bin/assets/js/110.d6160034.js"><link rel="prefetch" href="/bin/assets/js/111.8a0df6f4.js"><link rel="prefetch" href="/bin/assets/js/112.4efba584.js"><link rel="prefetch" href="/bin/assets/js/113.12b95897.js"><link rel="prefetch" href="/bin/assets/js/114.769adc32.js"><link rel="prefetch" href="/bin/assets/js/115.81399fad.js"><link rel="prefetch" href="/bin/assets/js/116.e6582f94.js"><link rel="prefetch" href="/bin/assets/js/117.e874d073.js"><link rel="prefetch" href="/bin/assets/js/118.85b191f9.js"><link rel="prefetch" href="/bin/assets/js/119.752b4524.js"><link rel="prefetch" href="/bin/assets/js/12.7c376396.js"><link rel="prefetch" href="/bin/assets/js/120.3e83b745.js"><link rel="prefetch" href="/bin/assets/js/121.54a7e287.js"><link rel="prefetch" href="/bin/assets/js/122.f595ae5d.js"><link rel="prefetch" href="/bin/assets/js/123.3c9a85cc.js"><link rel="prefetch" href="/bin/assets/js/124.e1c05686.js"><link rel="prefetch" href="/bin/assets/js/125.f49a52e2.js"><link rel="prefetch" href="/bin/assets/js/126.5f189b4a.js"><link rel="prefetch" href="/bin/assets/js/127.9900c91b.js"><link rel="prefetch" href="/bin/assets/js/128.61e2ba80.js"><link rel="prefetch" href="/bin/assets/js/129.6b580a67.js"><link rel="prefetch" href="/bin/assets/js/13.365e0e40.js"><link rel="prefetch" href="/bin/assets/js/130.1b4c012d.js"><link rel="prefetch" href="/bin/assets/js/131.a90c4ff2.js"><link rel="prefetch" href="/bin/assets/js/132.1a46fb32.js"><link rel="prefetch" href="/bin/assets/js/133.0a034903.js"><link rel="prefetch" href="/bin/assets/js/134.12419c54.js"><link rel="prefetch" href="/bin/assets/js/135.1a9b92de.js"><link rel="prefetch" href="/bin/assets/js/136.8c286bd4.js"><link rel="prefetch" href="/bin/assets/js/137.a89a5de0.js"><link rel="prefetch" href="/bin/assets/js/138.3836d054.js"><link rel="prefetch" href="/bin/assets/js/139.8f211eb7.js"><link rel="prefetch" href="/bin/assets/js/14.60aef346.js"><link rel="prefetch" href="/bin/assets/js/140.885aa2b1.js"><link rel="prefetch" href="/bin/assets/js/141.ac3d232b.js"><link rel="prefetch" href="/bin/assets/js/142.ea153360.js"><link rel="prefetch" href="/bin/assets/js/143.02267bea.js"><link rel="prefetch" href="/bin/assets/js/144.0a514899.js"><link rel="prefetch" href="/bin/assets/js/145.23e9c48f.js"><link rel="prefetch" href="/bin/assets/js/146.fed0e99f.js"><link rel="prefetch" href="/bin/assets/js/147.e9c21956.js"><link rel="prefetch" href="/bin/assets/js/148.d04e6a80.js"><link rel="prefetch" href="/bin/assets/js/149.43acfeb4.js"><link rel="prefetch" href="/bin/assets/js/15.4f41dc04.js"><link rel="prefetch" href="/bin/assets/js/150.b887f5b3.js"><link rel="prefetch" href="/bin/assets/js/151.34475c9e.js"><link rel="prefetch" href="/bin/assets/js/152.922dd46a.js"><link rel="prefetch" href="/bin/assets/js/153.a31a5eb3.js"><link rel="prefetch" href="/bin/assets/js/154.8a38fa15.js"><link rel="prefetch" href="/bin/assets/js/155.cad47536.js"><link rel="prefetch" href="/bin/assets/js/156.13b949ee.js"><link rel="prefetch" href="/bin/assets/js/157.7bc1587c.js"><link rel="prefetch" href="/bin/assets/js/158.a8fee864.js"><link rel="prefetch" href="/bin/assets/js/159.3f963551.js"><link rel="prefetch" href="/bin/assets/js/16.22e76992.js"><link rel="prefetch" href="/bin/assets/js/160.02ac5129.js"><link rel="prefetch" href="/bin/assets/js/161.0be16f8e.js"><link rel="prefetch" href="/bin/assets/js/162.9f7e78d8.js"><link rel="prefetch" href="/bin/assets/js/163.95d431ca.js"><link rel="prefetch" href="/bin/assets/js/164.a72aafb8.js"><link rel="prefetch" href="/bin/assets/js/165.d87b141c.js"><link rel="prefetch" href="/bin/assets/js/166.5a3ee3d4.js"><link rel="prefetch" href="/bin/assets/js/167.0554e946.js"><link rel="prefetch" href="/bin/assets/js/168.8b7ee686.js"><link rel="prefetch" href="/bin/assets/js/169.d6789c1f.js"><link rel="prefetch" href="/bin/assets/js/17.dac1bf83.js"><link rel="prefetch" href="/bin/assets/js/170.ecc80072.js"><link rel="prefetch" href="/bin/assets/js/171.68583bc4.js"><link rel="prefetch" href="/bin/assets/js/172.51ebd3b5.js"><link rel="prefetch" href="/bin/assets/js/173.0b24dee9.js"><link rel="prefetch" href="/bin/assets/js/174.db62b063.js"><link rel="prefetch" href="/bin/assets/js/175.ca5444c6.js"><link rel="prefetch" href="/bin/assets/js/176.f117647e.js"><link rel="prefetch" href="/bin/assets/js/177.724081ca.js"><link rel="prefetch" href="/bin/assets/js/178.0d34302e.js"><link rel="prefetch" href="/bin/assets/js/179.b411845c.js"><link rel="prefetch" href="/bin/assets/js/18.20cf55d2.js"><link rel="prefetch" href="/bin/assets/js/180.8971a1b3.js"><link rel="prefetch" href="/bin/assets/js/181.3a9d6d9e.js"><link rel="prefetch" href="/bin/assets/js/182.bc8792d1.js"><link rel="prefetch" href="/bin/assets/js/183.b4305b21.js"><link rel="prefetch" href="/bin/assets/js/184.a61c6786.js"><link rel="prefetch" href="/bin/assets/js/185.73dda28a.js"><link rel="prefetch" href="/bin/assets/js/186.2434f01f.js"><link rel="prefetch" href="/bin/assets/js/187.520ca03d.js"><link rel="prefetch" href="/bin/assets/js/188.32f679d0.js"><link rel="prefetch" href="/bin/assets/js/189.df1634dd.js"><link rel="prefetch" href="/bin/assets/js/19.dc867a25.js"><link rel="prefetch" href="/bin/assets/js/190.a2f13c96.js"><link rel="prefetch" href="/bin/assets/js/191.4fbe66dd.js"><link rel="prefetch" href="/bin/assets/js/192.54426c9d.js"><link rel="prefetch" href="/bin/assets/js/193.8a9b89f1.js"><link rel="prefetch" href="/bin/assets/js/194.7b16b6a6.js"><link rel="prefetch" href="/bin/assets/js/195.24b59fee.js"><link rel="prefetch" href="/bin/assets/js/196.81070e1a.js"><link rel="prefetch" href="/bin/assets/js/197.8a347f54.js"><link rel="prefetch" href="/bin/assets/js/198.02cbba40.js"><link rel="prefetch" href="/bin/assets/js/199.b3982ebe.js"><link rel="prefetch" href="/bin/assets/js/20.3d17b188.js"><link rel="prefetch" href="/bin/assets/js/200.936a0538.js"><link rel="prefetch" href="/bin/assets/js/21.bf3dbd66.js"><link rel="prefetch" href="/bin/assets/js/22.4e5ad062.js"><link rel="prefetch" href="/bin/assets/js/23.44e43477.js"><link rel="prefetch" href="/bin/assets/js/24.c3bc4453.js"><link rel="prefetch" href="/bin/assets/js/25.7c691197.js"><link rel="prefetch" href="/bin/assets/js/26.453fec25.js"><link rel="prefetch" href="/bin/assets/js/27.cc2a3792.js"><link rel="prefetch" href="/bin/assets/js/28.80eb64d7.js"><link rel="prefetch" href="/bin/assets/js/29.7a7d0769.js"><link rel="prefetch" href="/bin/assets/js/3.1a052628.js"><link rel="prefetch" href="/bin/assets/js/30.47283eb4.js"><link rel="prefetch" href="/bin/assets/js/31.99f0a2bd.js"><link rel="prefetch" href="/bin/assets/js/32.bae926c5.js"><link rel="prefetch" href="/bin/assets/js/33.86fa460c.js"><link rel="prefetch" href="/bin/assets/js/34.d5db8edf.js"><link rel="prefetch" href="/bin/assets/js/35.8162cbbc.js"><link rel="prefetch" href="/bin/assets/js/36.563661f3.js"><link rel="prefetch" href="/bin/assets/js/37.8b63deef.js"><link rel="prefetch" href="/bin/assets/js/38.79470ce8.js"><link rel="prefetch" href="/bin/assets/js/39.b167ab07.js"><link rel="prefetch" href="/bin/assets/js/4.ee23dd2c.js"><link rel="prefetch" href="/bin/assets/js/40.94b54960.js"><link rel="prefetch" href="/bin/assets/js/41.647d1a23.js"><link rel="prefetch" href="/bin/assets/js/42.6048e9b3.js"><link rel="prefetch" href="/bin/assets/js/43.0f54e5ed.js"><link rel="prefetch" href="/bin/assets/js/44.fae412b5.js"><link rel="prefetch" href="/bin/assets/js/45.3efa351e.js"><link rel="prefetch" href="/bin/assets/js/46.8b8377c6.js"><link rel="prefetch" href="/bin/assets/js/47.24439c8d.js"><link rel="prefetch" href="/bin/assets/js/48.e2192574.js"><link rel="prefetch" href="/bin/assets/js/49.407af329.js"><link rel="prefetch" href="/bin/assets/js/5.476dcac2.js"><link rel="prefetch" href="/bin/assets/js/50.668533ea.js"><link rel="prefetch" href="/bin/assets/js/52.346e869a.js"><link rel="prefetch" href="/bin/assets/js/53.9d6042d3.js"><link rel="prefetch" href="/bin/assets/js/54.98272551.js"><link rel="prefetch" href="/bin/assets/js/55.6c722699.js"><link rel="prefetch" href="/bin/assets/js/56.cf4ef7e0.js"><link rel="prefetch" href="/bin/assets/js/57.fe7638ea.js"><link rel="prefetch" href="/bin/assets/js/58.ac3fe883.js"><link rel="prefetch" href="/bin/assets/js/59.12448730.js"><link rel="prefetch" href="/bin/assets/js/6.55d50cdb.js"><link rel="prefetch" href="/bin/assets/js/60.5b4015e2.js"><link rel="prefetch" href="/bin/assets/js/61.813fb8f3.js"><link rel="prefetch" href="/bin/assets/js/62.e414e61a.js"><link rel="prefetch" href="/bin/assets/js/63.8c4af6bc.js"><link rel="prefetch" href="/bin/assets/js/64.a22ce66c.js"><link rel="prefetch" href="/bin/assets/js/65.de378ccc.js"><link rel="prefetch" href="/bin/assets/js/66.0c902148.js"><link rel="prefetch" href="/bin/assets/js/67.f76d8708.js"><link rel="prefetch" href="/bin/assets/js/68.30a31a71.js"><link rel="prefetch" href="/bin/assets/js/69.63086921.js"><link rel="prefetch" href="/bin/assets/js/7.d5f2b9d8.js"><link rel="prefetch" href="/bin/assets/js/70.db4b11a9.js"><link rel="prefetch" href="/bin/assets/js/71.6c0fc4ee.js"><link rel="prefetch" href="/bin/assets/js/72.18257ddb.js"><link rel="prefetch" href="/bin/assets/js/73.ead5b399.js"><link rel="prefetch" href="/bin/assets/js/74.835af730.js"><link rel="prefetch" href="/bin/assets/js/75.e2929063.js"><link rel="prefetch" href="/bin/assets/js/76.84591759.js"><link rel="prefetch" href="/bin/assets/js/77.adb85078.js"><link rel="prefetch" href="/bin/assets/js/78.033c67d1.js"><link rel="prefetch" href="/bin/assets/js/79.6b830cd6.js"><link rel="prefetch" href="/bin/assets/js/8.11b702fd.js"><link rel="prefetch" href="/bin/assets/js/80.100b010c.js"><link rel="prefetch" href="/bin/assets/js/81.b64d1418.js"><link rel="prefetch" href="/bin/assets/js/82.5142ca05.js"><link rel="prefetch" href="/bin/assets/js/83.00bb1269.js"><link rel="prefetch" href="/bin/assets/js/84.847c1e6e.js"><link rel="prefetch" href="/bin/assets/js/85.4e27ceb7.js"><link rel="prefetch" href="/bin/assets/js/86.68312164.js"><link rel="prefetch" href="/bin/assets/js/87.531e14de.js"><link rel="prefetch" href="/bin/assets/js/88.bc982616.js"><link rel="prefetch" href="/bin/assets/js/89.2b52b75b.js"><link rel="prefetch" href="/bin/assets/js/9.8036c1b5.js"><link rel="prefetch" href="/bin/assets/js/90.166e07d5.js"><link rel="prefetch" href="/bin/assets/js/91.f5685558.js"><link rel="prefetch" href="/bin/assets/js/92.6583a882.js"><link rel="prefetch" href="/bin/assets/js/93.5b1b2fa2.js"><link rel="prefetch" href="/bin/assets/js/94.aee56333.js"><link rel="prefetch" href="/bin/assets/js/95.4cad3b8d.js"><link rel="prefetch" href="/bin/assets/js/96.eb08c2fc.js"><link rel="prefetch" href="/bin/assets/js/97.25d00416.js"><link rel="prefetch" href="/bin/assets/js/98.b34434cd.js"><link rel="prefetch" href="/bin/assets/js/99.0e6b5f13.js">
    <link rel="stylesheet" href="/bin/assets/css/0.styles.9cb74ece.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/bin/" aria-current="page" class="home-link router-link-exact-active router-link-active"><img src="/bin/img/EB-logo.png" alt="成功源于每天的积累" class="logo"> <span class="site-name can-hide">成功源于每天的积累</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/bin/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端文章
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/bin/pages/8143cc480faf9a11/" class="nav-link">
  JavaScript
</a></li></ul></li><li class="dropdown-item"><h4>
          学习笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/bin/note/javascript/" class="nav-link">
  《JavaScript教程》
</a></li><li class="dropdown-subitem"><a href="/bin/note/js/" class="nav-link">
  《JavaScript高级程序设计》
</a></li><li class="dropdown-subitem"><a href="/bin/note/es6/" class="nav-link">
  《ES6 教程》
</a></li><li class="dropdown-subitem"><a href="/bin/note/vue/" class="nav-link">
  《Vue》
</a></li><li class="dropdown-subitem"><a href="/bin/note/react/" class="nav-link">
  《React》
</a></li><li class="dropdown-subitem"><a href="/bin/note/typescript-axios/" class="nav-link">
  《TypeScript 从零实现 axios》
</a></li><li class="dropdown-subitem"><a href="/bin/note/git/" class="nav-link">
  《Git》
</a></li><li class="dropdown-subitem"><a href="/bin/pages/51afd6/" class="nav-link">
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/bin/pages/4643cd/" class="nav-link">
  JS设计模式总结
</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/bin/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端文章
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/bin/pages/8143cc480faf9a11/" class="nav-link">
  JavaScript
</a></li></ul></li><li class="dropdown-item"><h4>
          学习笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/bin/note/javascript/" class="nav-link">
  《JavaScript教程》
</a></li><li class="dropdown-subitem"><a href="/bin/note/js/" class="nav-link">
  《JavaScript高级程序设计》
</a></li><li class="dropdown-subitem"><a href="/bin/note/es6/" class="nav-link">
  《ES6 教程》
</a></li><li class="dropdown-subitem"><a href="/bin/note/vue/" class="nav-link">
  《Vue》
</a></li><li class="dropdown-subitem"><a href="/bin/note/react/" class="nav-link">
  《React》
</a></li><li class="dropdown-subitem"><a href="/bin/note/typescript-axios/" class="nav-link">
  《TypeScript 从零实现 axios》
</a></li><li class="dropdown-subitem"><a href="/bin/note/git/" class="nav-link">
  《Git》
</a></li><li class="dropdown-subitem"><a href="/bin/pages/51afd6/" class="nav-link">
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/bin/pages/4643cd/" class="nav-link">
  JS设计模式总结
</a></li></ul></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#_1-图片懒加载问题">1.图片懒加载问题</a></li><li><a href="#_2-替换日期格式-zz-yy-xxxx-替换成-xxxx-zz-yy">2. 替换日期格式，zz-yy-xxxx 替换成 xxxx-zz-yy</a></li><li><a href="#_3-js-是一门面向对象的语言-说说面向对象语言的三大特征">3. JS 是一门面向对象的语言，说说面向对象语言的三大特征？</a></li><li><a href="#_4-js-函数中的继承主要是继承什么-可以继承函数体吗-原因是啥">4. js 函数中的继承主要是继承什么？可以继承函数体吗？原因是啥</a></li><li><a href="#_5-声明一个-fn-函数-并对其使用-typeof-结果返回什么-然后给-fn-添加一个属性-会报错不-为什么">5. 声明一个 fn 函数，并对其使用 typeof 结果返回什么，然后给 fn 添加一个属性，会报错不，为什么?</a></li><li><a href="#_6-定义一个字符串-对这个字符串使用-typeof-结果返回什么-既然返回了-string-字符串-而属性和方法是对象才有的-哪为什么可以在我定义的字符串上使用-split、join-、和-length-方法">6. 定义一个字符串，对这个字符串使用 typeof，结果返回什么？既然返回了 string 字符串，而属性和方法是对象才有的，哪为什么可以在我定义的字符串上使用 split、join()、和 length 方法</a></li><li><a href="#_7-我有一段文字-但不知道具体有多少字-我怎么实现单行的话居中显示-多行的话就靠左显示">7. 我有一段文字，但不知道具体有多少字，我怎么实现单行的话居中显示，多行的话就靠左显示？</a></li><li><a href="#_8-我想实现一段动画-我有哪些可选的实现方式-一段流畅的动画帧与帧之间间隔有什么要求">8. 我想实现一段动画，我有哪些可选的实现方式？一段流畅的动画帧与帧之间间隔有什么要求？</a></li><li><a href="#_9-什么是-mvvm">9. 什么是 mvvm?</a></li><li><a href="#_10-什么是-spa-单页面-它的优缺点分别是什么">10. 什么是 SPA 单页面，它的优缺点分别是什么</a></li><li><a href="#_11-生命周期">11. 生命周期</a></li><li><a href="#_12-v-show-与-v-if-的区别">12. v-show 与 v-if 的区别</a></li><li><a href="#_13-vue-的单向数据流">13. Vue 的单向数据流</a></li><li><a href="#_14-异步请求适合在哪个生命周期调用">14. 异步请求适合在哪个生命周期调用？</a></li><li><a href="#_16-8-什么是-ssr">16. 8.什么是 SSR</a></li><li><a href="#_17-vue-路由">17. Vue 路由</a></li><li><a href="#_18-你有对-vue-项目进行哪些优化">18. 你有对 Vue 项目进行哪些优化？</a></li><li><a href="#_19-vue-中的-key-有什么作用">19. Vue 中的 key 有什么作用？</a></li><li><a href="#_20-虚拟-dom-实现原理">20. 虚拟 DOM 实现原理</a></li><li><a href="#_21-虚拟-dom-的优缺点">21. 虚拟 DOM 的优缺点</a></li><li><a href="#_22-proxy-与-object-defineproperty-优劣对比">22. Proxy 与 Object.defineProperty 优劣对比</a></li><li><a href="#_23-computed-和-watch">23. Computed 和 Watch</a></li><li><a href="#_24-vue2-x-中如何监测数组变化">24. vue2.x 中如何监测数组变化</a></li><li><a href="#_25-vue-框架怎么实现对象和数组的监听">25. Vue 框架怎么实现对象和数组的监听？</a></li><li><a href="#_26-vue-是如何实现数据双向绑定的">26. Vue 是如何实现数据双向绑定的</a></li><li><a href="#_27-v-model-的原理">27. v-model 的原理</a></li><li><a href="#_28-组件中-data-为什么是一个函数">28. 组件中 data 为什么是一个函数？</a></li><li><a href="#_29-谈谈你对-keep-alive">29. 谈谈你对 keep-alive</a></li><li><a href="#_30-父组件可以监听到子组件的生命周期吗">30. 父组件可以监听到子组件的生命周期吗？</a></li><li><a href="#_31-说说-vue-内置指令">31. 说说 vue 内置指令</a></li><li><a href="#_32-vue3-0-用过吗-了解多少">32. Vue3.0 用过吗？了解多少？</a></li><li><a href="#_33-vue-router-路由钩子函数是什么-执行顺序是什么">33. vue-router 路由钩子函数是什么？执行顺序是什么？</a></li><li><a href="#_34-vue-router-动态路由是什么-有什么问题。">34. vue-router 动态路由是什么？有什么问题。</a></li><li><a href="#_35-vue-router-组件复用导致路由参数失效怎么办">35. vue-router 组件复用导致路由参数失效怎么办？</a></li><li><a href="#_36-谈一下对-vuex-的个人理解">### 36. 谈一下对 vuex 的个人理解</a></li><li><a href="#_37-vuex-页面刷新数据丢失怎么解决">37. Vuex 页面刷新数据丢失怎么解决？</a></li><li><a href="#_38-vuex-为什么要分模块并且加命名空间">38. Vuex 为什么要分模块并且加命名空间？</a></li><li><a href="#_39-使用过-vue-ssr-吗-说说-ssr">39. 使用过 Vue SSR 吗？说说 SSR</a></li><li><a href="#_40-vue-中使用了哪些设计模式">40. vue 中使用了哪些设计模式？</a></li><li><a href="#_41-vue-set-方法原理">41. Vue.set 方法原理</a></li><li><a href="#_42-vue-extend-作用和原理">42. Vue.extend 作用和原理</a></li><li><a href="#_43-写过自定义指令吗-原理是什么">43. 写过自定义指令吗？原理是什么？</a></li><li><a href="#_44-vue-模板编译原理">44. Vue 模板编译原理</a></li><li><a href="#_45-生命周期钩子是如何实现的">45. 生命周期钩子是如何实现的</a></li><li><a href="#_46-函数式组件使用场景和原理">46. 函数式组件使用场景和原理</a></li><li><a href="#_47-diff-算法了解吗">47. diff 算法了解吗？</a></li><li><a href="#_48-什么是双向绑定">48. 什么是双向绑定？</a></li><li><a href="#_49-双向绑定的原理是什么">49. 双向绑定的原理是什么？</a></li><li><a href="#_50-实现双向绑定">50. 实现双向绑定</a></li><li><a href="#_51-route和-router-的区别">51. $route和$router 的区别</a></li><li><a href="#_52-跨域的方法">52. 跨域的方法：</a></li><li><a href="#_53-异步管理">53. 异步管理：</a></li><li><a href="#_54-怎么定义-vue-router-的动态路由-怎么获取传过来的动态参数">54. 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数</a></li><li><a href="#_55-vue-router-有哪几种导航钩子">55. vue-router 有哪几种导航钩子？</a></li><li><a href="#_56-scss-是什么-在-vue-cli-中的安装使用步骤是-有哪几大特性">56. scss 是什么？在 vue.cli 中的安装使用步骤是？有哪几大特性？</a></li><li><a href="#_57-vue-loader-是什么-使用它的用途有哪些">57. vue-loader 是什么？使用它的用途有哪些？</a></li><li><a href="#_58-vue-如何实现按需加载配合-webpack-设置">58. vue 如何实现按需加载配合 webpack 设置?</a></li><li><a href="#_59-1-vuex-是什么-怎么使用-哪种功能场景使用它">59. （1）vuex 是什么？怎么使用？哪种功能场景使用它？</a></li><li><a href="#_60-聊聊你对-vue-js-的-template-编译的理解">60. 聊聊你对 Vue.js 的 template 编译的理解？</a></li></ul></div><p></p> <h3 id="_1-图片懒加载问题"><a href="#_1-图片懒加载问题" class="header-anchor">#</a> 1.图片懒加载问题</h3> <p>(1) 什么是图片懒加载？</p> <p>答: 进入页面时，只加载可视区域内的图片资源，当我们向下滚动的时候图片资源才会被请求到，这就是图片懒加载</p> <p>(2)为什么要做图片懒加载？</p> <p>图片懒加载就是网页性能优化的一种方式，可以提升用户体验，节省用户流量图片懒加载图片的标签是img标签，图片的主要来源也是根据img标签的src来实现的</p> <p>(3)vue----自定义指令-懒加载</p> <h3 id="_2-替换日期格式-zz-yy-xxxx-替换成-xxxx-zz-yy"><a href="#_2-替换日期格式-zz-yy-xxxx-替换成-xxxx-zz-yy" class="header-anchor">#</a> 2. 替换日期格式，zz-yy-xxxx 替换成 xxxx-zz-yy</h3> <div class="language- extra-class"><pre class="language-text"><code>var reg = /(\d{2})\.(\d{2})\/(\d{4})/

var data = '10.24/2017'

data = data.replace(reg, '$3-$1-$2')

console.log(data)//2017-10-24
</code></pre></div><h3 id="_3-js-是一门面向对象的语言-说说面向对象语言的三大特征"><a href="#_3-js-是一门面向对象的语言-说说面向对象语言的三大特征" class="header-anchor">#</a> 3. JS 是一门面向对象的语言，说说面向对象语言的三大特征？</h3> <p>三大特征是：封装、继承和多态。</p> <p>封装是指隐藏逻辑实现过程，只对外暴露方法与属性，使用者只需要了解是如何使用的就行，不必关心内部是如何实现的，目的是为了简化实现过程，做到多处复用，提高开发效率。当需要维护时，业务逻辑与工具功能是分开的，降低迭代成本</p> <p>继承是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。这非常类似大自然中的物种遗传。</p> <p>多态性是指允许不同类的对象对同一消息作出响应。比如同样的加法，把两个时间加在一起和把两个整数加在一起肯定完全不同。又比如，同样的选择编辑-粘贴操作，在字处理程序和绘图程序中有不同的效果。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p> <h3 id="_4-js-函数中的继承主要是继承什么-可以继承函数体吗-原因是啥"><a href="#_4-js-函数中的继承主要是继承什么-可以继承函数体吗-原因是啥" class="header-anchor">#</a> 4. js 函数中的继承主要是继承什么？可以继承函数体吗？原因是啥</h3> <p>JS 函数的继承主要继承的是函数名，没办法实现函数体继承。</p> <h3 id="_5-声明一个-fn-函数-并对其使用-typeof-结果返回什么-然后给-fn-添加一个属性-会报错不-为什么"><a href="#_5-声明一个-fn-函数-并对其使用-typeof-结果返回什么-然后给-fn-添加一个属性-会报错不-为什么" class="header-anchor">#</a> 5. 声明一个 fn 函数，并对其使用 typeof 结果返回什么，然后给 fn 添加一个属性，会报错不，为什么?</h3> <p>结果返回 function 字符串，给 fn 添加属性不会报错，因为函数本身就是一种 object 对象，给对象添加属性是不会报错的。</p> <h3 id="_6-定义一个字符串-对这个字符串使用-typeof-结果返回什么-既然返回了-string-字符串-而属性和方法是对象才有的-哪为什么可以在我定义的字符串上使用-split、join-、和-length-方法"><a href="#_6-定义一个字符串-对这个字符串使用-typeof-结果返回什么-既然返回了-string-字符串-而属性和方法是对象才有的-哪为什么可以在我定义的字符串上使用-split、join-、和-length-方法" class="header-anchor">#</a> 6. 定义一个字符串，对这个字符串使用 typeof，结果返回什么？既然返回了 string 字符串，而属性和方法是对象才有的，哪为什么可以在我定义的字符串上使用 split、join()、和 length 方法</h3> <p>在全局环境中存在简单数据类型的对象，而字符串对象就是其中的一种，所有字符串都是这个对象的实例，当我们对字符串使用属性与方法时，字符串本身其实是没有对应方法的，这个时候，js 会沿着作用域往上寻找，最终在 string 对象上找到了对应的属性与方法</p> <h3 id="_7-我有一段文字-但不知道具体有多少字-我怎么实现单行的话居中显示-多行的话就靠左显示"><a href="#_7-我有一段文字-但不知道具体有多少字-我怎么实现单行的话居中显示-多行的话就靠左显示" class="header-anchor">#</a> 7. 我有一段文字，但不知道具体有多少字，我怎么实现单行的话居中显示，多行的话就靠左显示？</h3> <div class="language- extra-class"><pre class="language-text"><code>display: flex;
flex-direction: row;
justify-content: center;
</code></pre></div><h3 id="_8-我想实现一段动画-我有哪些可选的实现方式-一段流畅的动画帧与帧之间间隔有什么要求"><a href="#_8-我想实现一段动画-我有哪些可选的实现方式-一段流畅的动画帧与帧之间间隔有什么要求" class="header-anchor">#</a> 8. 我想实现一段动画，我有哪些可选的实现方式？一段流畅的动画帧与帧之间间隔有什么要求？</h3> <p>答：html5 动画，js 动画，CSS3 动画。多数情况下最高的绘制频率只能是每秒 60 帧(frame per second)，对应于显示器的 60Hz，低于这个频率，肉眼感觉画面卡顿不流畅，高于这个频率，及其耗费性能。因此通常采用的时间间隔就是 1/60,也就是 16.7ms。</p> <h3 id="_9-什么是-mvvm"><a href="#_9-什么是-mvvm" class="header-anchor">#</a> 9. 什么是 mvvm?</h3> <p>MVVM 的核心是数据驱动即 ViewModel，ViewModel 是 View 和 Model 的关系映射。MVVM 本质就是基于操作数据来操作视图进而操作 DOM，借助于 MVVM 无需直接操作 DOM，开发者只需编写 ViewModel 中有业务，使得 View 完全实现自动化。</p> <h3 id="_10-什么是-spa-单页面-它的优缺点分别是什么"><a href="#_10-什么是-spa-单页面-它的优缺点分别是什么" class="header-anchor">#</a> 10. 什么是 SPA 单页面，它的优缺点分别是什么</h3> <p>SPA（ single-page application ）即一个web项目就只有一个页面（即一个HTML文件,HTML 内容的变换是利用路由机制实现的。仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <p><strong>优点:</strong>
用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p> <p>基于上面一点，SPA 相对对服务器压力小；</p> <p>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p> <p><strong>缺点：</strong>
初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p> <p>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p> <p>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p> <h3 id="_11-生命周期"><a href="#_11-生命周期" class="header-anchor">#</a> 11. 生命周期</h3> <p>(1) 基本概念</p> <p>★ 什么是vue生命周期？ Vue 实例从创建到销毁的过程，就是生命周期。”</p> <p>注意：浏览器有8个钩子，但是node中做服务端渲染的时候只有beforeCreate和created</p> <p>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p> <p>created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p> <p>beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p> <p>mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p> <p>beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p> <p>updated发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p> <p>beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器，销毁父组件对子组件的重复监听。beforeDestroy(){Bus.$off(&quot;saveTheme&quot;)}</p> <p>destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p> <p>(2)生命周期调用顺序</p> <p>组件的调用顺序都是先父后子</p> <p>渲染完成的顺序是先子后父</p> <p>组件的销毁操作是先父后子</p> <p>销毁完成的顺序是先子后父</p> <p>加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</p> <p>子组件更新过程 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p> <p>父组件更新过程 父 beforeUpdate -&gt; 父 updated</p> <p>销毁过程 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p> <p>(3)vue生命周期的作用是什么</p> <p>它的生命周期中有多个事件钩子，让我们控制Vue实例过程更加清晰。</p> <p>(4)第一次页面加载会触发哪几个钩子</p> <p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p> <p>(5) 每个周期具体适合哪些场景</p> <p>beforecreate : 可以在这加个loading事件，在加载实例时触发</p> <p>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</p> <p>mounted : 挂载元素，获取到DOM节点</p> <p>updated : 如果对数据统一处理，在这里写上相应函数</p> <p>beforeDestroy : 可以清除定时器</p> <p>nextTick : 更新数据后立即操作dom</p> <h3 id="_12-v-show-与-v-if-的区别"><a href="#_12-v-show-与-v-if-的区别" class="header-anchor">#</a> 12. v-show 与 v-if 的区别</h3> <p>v-if</p> <p>是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；</p> <p>也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p> <p>v-show</p> <p>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p> <p>所以:
v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；
v-show 则适用于需要非常频繁切换条件的场景。</p> <h3 id="_13-vue-的单向数据流"><a href="#_13-vue-的单向数据流" class="header-anchor">#</a> 13. Vue 的单向数据流</h3> <p>背景：</p> <p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向变的混乱。</p> <p>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <p>有两种常见的试图改变一个 prop 的情形 :</p> <p>这个 prop 用来传递一个初始值；
这个子组件接下来希望将其作为一个本地的 prop 数据来使用。
在这种情况下，最好定义一个本地的 data属性并将这个 prop 用作其初始值：</p> <div class="language- extra-class"><pre><code>```
props: ['initialCounter'],
data: function () {
  return {
  counter: this.initialCounter //定义本地的data属性接收prop初始值
  }
}
```
</code></pre></div><p>这个 prop 以一种原始的值传入且需要进行转换。
在这种情况下，最好使用这个 prop 的值来定义一个计算属性
<code>props: ['size'], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } }</code></p> <h3 id="_14-异步请求适合在哪个生命周期调用"><a href="#_14-异步请求适合在哪个生命周期调用" class="header-anchor">#</a> 14. 异步请求适合在哪个生命周期调用？</h3> <div class="language- extra-class"><pre><code>官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用。

本人推荐在 created 钩子函数中调用异步请求，有以下优点：

能更快获取到服务端数据，减少页面 loading 时间；

ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
</code></pre></div><h3 id="_16-8-什么是-ssr"><a href="#_16-8-什么是-ssr" class="header-anchor">#</a> 16. 8.什么是 SSR</h3> <div class="language- extra-class"><pre><code>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。

服务端渲染 SSR 的优缺点如下：

（1）服务端渲染的优点：

​更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲	染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

​更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面	直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

（2) 服务端渲染的缺点：

更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

更多的服务器负载： 在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。
</code></pre></div><h3 id="_17-vue-路由"><a href="#_17-vue-路由" class="header-anchor">#</a> 17. Vue 路由</h3> <div class="language- extra-class"><pre><code>(1) vue-router 路由模式有几种？

vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：

```
switch (mode) {
 case 'history':
     this.history = new HTML5History(this, options.base)
     break
 case 'hash':
     this.history = new HashHistory(this, options.base, this.fallback)
     break
 case 'abstract':
     this.history = new AbstractHistory(this, options.base)
     break
 default:
     if (process.env.NODE_ENV !== 'production') {
      assert(false, `invalid mode: ${mode}`)
     }
}
```

三 种路由模式的说明如下：

hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；

history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；

abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

(2) hash路由和history路由实现原理

​	[1]hash 模式的实现原理

早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：

https://www.word.com#search复制代码

hash 路由模式的实现主要是基于下面几个特性：

URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；

hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；

可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；

我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

​	[2]history 模式的实现原理

HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：

window.history.pushState(null, null, path);

window.history.replaceState(null, null, path);复制代码

history 路由模式的实现主要基于存在下面几个特性：

pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；

我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；

history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
</code></pre></div><h3 id="_18-你有对-vue-项目进行哪些优化"><a href="#_18-你有对-vue-项目进行哪些优化" class="header-anchor">#</a> 18. 你有对 Vue 项目进行哪些优化？</h3> <div class="language- extra-class"><pre><code>（1）代码层面的优化

​	v-if 和 v-show 区分使用场景

​	computed 和 watch 区分使用场景

​	v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

​	长列表性能优化

​	事件的销毁

​	图片资源懒加载

​	路由懒加载

​	第三方插件的按需引入

​	优化无限列表性能

​	服务端渲染 SSR or 预渲染

（2）Webpack 层面的优化

​	Webpack 对图片进行压缩-------先引入npm install image-webpack-loader --save-dev，然后在 webpack.config.js 中配置

​	减少 ES6 转为 ES5 的冗余代码

​	提取公共代码

​	模板预编译

​	提取组件的 CSS

​	优化 SourceMap

​	构建结果输出分析

​	Vue 项目的编译优化

（3）基础的 Web 技术的优化

​	开启 gzip 压缩

​	浏览器缓存

​	CDN 的使用

​	使用 Chrome Performance 查找性能瓶颈
</code></pre></div><h3 id="_19-vue-中的-key-有什么作用"><a href="#_19-vue-中的-key-有什么作用" class="header-anchor">#</a> 19. Vue 中的 key 有什么作用？</h3> <div class="language- extra-class"><pre><code>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。
 Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。

所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速

更准确因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。

更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：

```
function createKeyToOldIdx (children, beginIdx, endIdx) {
 let i, key
 const map = {}
 for (i = beginIdx; i &lt;= endIdx; ++i) {
  key = children[i].key
  if (isDef(key)) map[key] = i
 }
 return map
}
```
</code></pre></div><h3 id="_20-虚拟-dom-实现原理"><a href="#_20-虚拟-dom-实现原理" class="header-anchor">#</a> 20. 虚拟 DOM 实现原理</h3> <div class="language- extra-class"><pre><code>虚拟 DOM 的实现原理主要包括以下 3 部分：

用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；

diff 算法 — 比较两棵虚拟 DOM 树的差异；

pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

[详情点击这里](https://juejin.im/post/6844903895467032589#heading-14)
</code></pre></div><h3 id="_21-虚拟-dom-的优缺点"><a href="#_21-虚拟-dom-的优缺点" class="header-anchor">#</a> 21. 虚拟 DOM 的优缺点</h3> <div class="language- extra-class"><pre><code>优点：

保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；

跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点:

无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
</code></pre></div><h3 id="_22-proxy-与-object-defineproperty-优劣对比"><a href="#_22-proxy-与-object-defineproperty-优劣对比" class="header-anchor">#</a> 22. Proxy 与 Object.defineProperty 优劣对比</h3> <div class="language- extra-class"><pre><code>Proxy 的优势如下:

Proxy 可以直接监听对象而非属性；

Proxy 可以直接监听数组的变化；

Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；

Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；

Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

Object.defineProperty 的优势如下:

兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平


(1)Vue2.x响应式数据原理

Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)

(2)Vue3.x响应式数据原理

Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。
</code></pre></div><h3 id="_23-computed-和-watch"><a href="#_23-computed-和-watch" class="header-anchor">#</a> 23. Computed 和 Watch</h3> <div class="language- extra-class"><pre><code>computed:

computed是计算属性,也就是计算值,它更多用于计算值的场景

computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算

computed适用于计算比较消耗性能的计算场景

watch:

更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作

无缓存性，页面重新渲染时值不变化也会执行

小结:

当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed
如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化
</code></pre></div><h3 id="_24-vue2-x-中如何监测数组变化"><a href="#_24-vue2-x-中如何监测数组变化" class="header-anchor">#</a> 24. vue2.x 中如何监测数组变化</h3> <div class="language- extra-class"><pre><code>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。
</code></pre></div><h3 id="_25-vue-框架怎么实现对象和数组的监听"><a href="#_25-vue-框架怎么实现对象和数组的监听" class="header-anchor">#</a> 25. Vue 框架怎么实现对象和数组的监听？</h3> <div class="language- extra-class"><pre><code>Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。
</code></pre></div><h3 id="_26-vue-是如何实现数据双向绑定的"><a href="#_26-vue-是如何实现数据双向绑定的" class="header-anchor">#</a> 26. Vue 是如何实现数据双向绑定的</h3> <div class="language- extra-class"><pre><code>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据

输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。

其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。

Vue 主要通过以下 4 个步骤来实现数据双向绑定的：

实现一个监听器 Observer对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

实现一个解析器 Compile解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

实现一个订阅器 Dep订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。
</code></pre></div><h3 id="_27-v-model-的原理"><a href="#_27-v-model-的原理" class="header-anchor">#</a> 27. v-model 的原理</h3> <div class="language- extra-class"><pre><code>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

text 和 textarea 元素使用 value 属性和 input 事件；

checkbox 和 radio 使用 checked 属性和 change 事件；

select 字段将 value 作为 prop 并将 change 作为事件。

以 input 表单元素为例：

```
&lt;input v-model='something'&gt;
```

相当于

```
&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
```
</code></pre></div><h3 id="_28-组件中-data-为什么是一个函数"><a href="#_28-组件中-data-为什么是一个函数" class="header-anchor">#</a> 28. 组件中 data 为什么是一个函数？</h3> <div class="language- extra-class"><pre><code>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？

```
// data

data() {
 return {
   message: &quot;子组件&quot;,
   childName:this.name
 }
}
```

```
// new Vue

new Vue({
el: '#app',
router,
template: '&lt;App/&gt;',
components: {App}
})
```

一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。 而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。
</code></pre></div><h3 id="_29-谈谈你对-keep-alive"><a href="#_29-谈谈你对-keep-alive" class="header-anchor">#</a> 29. 谈谈你对 keep-alive</h3> <div class="language- extra-class"><pre><code>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：

一般结合路由和动态组件一起使用，用于缓存组件；

提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；

对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

keep-alive的生命周期

activated： 页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated

deactivated: 页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated
</code></pre></div><h3 id="_30-父组件可以监听到子组件的生命周期吗"><a href="#_30-父组件可以监听到子组件的生命周期吗" class="header-anchor">#</a> 30. 父组件可以监听到子组件的生命周期吗？</h3> <div class="language- extra-class"><pre><code>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

```
// Parent.vue

&lt;Child @mounted=&quot;doSomething&quot;/&gt;
```

```
// Child.vue

mounted() {
 this.$emit(&quot;mounted&quot;);
}
```

以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：

```
// Parent.vue

&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
  console.log('父组件监听到 mounted 钩子函数 ...');
},
```

```
// Child.vue
mounted(){
  console.log('子组件触发 mounted 钩子函数 ...');
},
```

// 以上输出顺序为：

// 子组件触发 mounted 钩子函数 ...

// 父组件监听到 mounted 钩子函数 ... 复制代码

当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。
</code></pre></div><h3 id="_31-说说-vue-内置指令"><a href="#_31-说说-vue-内置指令" class="header-anchor">#</a> 31. 说说 vue 内置指令</h3> <div class="language- extra-class"><pre><code>v-once - 定义它的元素或组件只渲染一次，包括元素或组件的所有节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。

v-cloak - 这个指令保持在元素上直到关联实例结束编译 -- 解决初始化慢到页面闪动的最佳实践。

v-bind - 绑定属性，动态更新HTML元素上的属性。例如 v-bind:class。

v-on - 用于监听DOM事件。例如 v-on:click v-on:keyup

v-html - 赋值就是变量的innerHTML -- 注意防止xss攻击

v-text - 更新元素的textContent

v-model - 1、在普通标签。变成value和input的语法糖，并且会处理拼音输入法的问题。2、再组件上。也是处理value和input语法糖。

v-if / v-else / v-else-if。可以配合template使用；在render函数里面就是三元表达式。

v-show - 使用指令来实现 -- 最终会通过display来进行显示隐藏

v-for - 循环指令编译出来的结果是 -L 代表渲染列表。优先级比v-if高最好不要一起使用，尽量使用计算属性去解决。注意增加唯一key值，不要使用index作为key。

v-pre - 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度。
</code></pre></div><h3 id="_32-vue3-0-用过吗-了解多少"><a href="#_32-vue3-0-用过吗-了解多少" class="header-anchor">#</a> 32. Vue3.0 用过吗？了解多少？</h3> <div class="language- extra-class"><pre><code>响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty。

组件选项声明方式 Vue3.x 使用 Composition API setup是Vue3.x新增的一个选项，他是组件内使用Composition API 的入口。

模板语法变化 slot 具名插槽语法，自定义指令v-model升级。

其他方面的更改 Suspense支持Fragment（多个根节点）和 Protal（在dom其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。基于 treeShaking 优化，提供了更多的内置功能。
</code></pre></div><h3 id="_33-vue-router-路由钩子函数是什么-执行顺序是什么"><a href="#_33-vue-router-路由钩子函数是什么-执行顺序是什么" class="header-anchor">#</a> 33. vue-router 路由钩子函数是什么？执行顺序是什么？</h3> <div class="language- extra-class"><pre><code>路由钩子的执行流程，钩子函数种类有：全局守卫、路由守卫、组件守卫。

完整的导航解析流程：
 1、导航被触发。
 2、在失活的组件里调用 beforeRouterLeave 守卫。
 3、调用全局的 beforeEach 守卫。
 4、在重用的组件调用 beforeRouterUpdate 守卫（2.2+）。
 5、在路由配置里面 beforeEnter。
 6、解析异步路由组件。
 7、在被激活的组件里调用 beforeRouterEnter。
 8、调用全局的 beforeResolve 守卫（2.5+）。
 9、导航被确认。
 10、调用全局的 afterEach 钩子。
 11、触发 DOM 更新。
 12、调用 beforeRouterEnter 守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。
</code></pre></div><h3 id="_34-vue-router-动态路由是什么-有什么问题。"><a href="#_34-vue-router-动态路由是什么-有什么问题。" class="header-anchor">#</a> 34. vue-router 动态路由是什么？有什么问题。</h3> <div class="language- extra-class"><pre><code>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”（dynamic segment）来达到这个效果：

```
const User = {
 template: &quot;
User
&quot;, };
 const router = new VueRouter({
 routes: [
 // 动态路径参数 以冒号开头
 { path: &quot;/user/:id&quot;, component: User },
 ],
 });
```
</code></pre></div><h3 id="_35-vue-router-组件复用导致路由参数失效怎么办"><a href="#_35-vue-router-组件复用导致路由参数失效怎么办" class="header-anchor">#</a> 35. vue-router 组件复用导致路由参数失效怎么办？</h3> <div class="language- extra-class"><pre><code> 解决方案：
 1、通过watch监听路由参数再发请求

```
 watch：{
 &quot;router&quot;:function(){
 		this.getData(this.$router.params.xxx)
 	}
 }
```

 2、用 :key来阻止复用

```
router-view :key=&quot;$route.fullPath&quot;
```
</code></pre></div><h3 id="_36-谈一下对-vuex-的个人理解"><a href="#_36-谈一下对-vuex-的个人理解" class="header-anchor">#</a> ### 36. 谈一下对 vuex 的个人理解</h3> <div class="language- extra-class"><pre><code>vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部内心原理是通过创造一个全局实例 new Vue）

![IMG_256](file:///C:\Users\18225\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg)

主要包括以下几个模块：

State:定义了应用状态的数据结构，可以在这里设置默认的初始化状态。

Getter:允许组件从Store中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。

Mutation:是唯一更改 store 中状态的方法，且必须是同步函数。

Action:用于提交 mutation，而不是直接变更状态，可以包含任意异步请求。

Module:允许将单一的 Store 拆分更多个 store 且同时保存在单一的状态树中。
</code></pre></div><h3 id="_37-vuex-页面刷新数据丢失怎么解决"><a href="#_37-vuex-页面刷新数据丢失怎么解决" class="header-anchor">#</a> 37. Vuex 页面刷新数据丢失怎么解决？</h3> <div class="language- extra-class"><pre><code>需要做 vuex 数据持久化，一般使用本地储存的方案来保存数据，可以自己设计存储方案，也可以使用第三方插件。
 推荐使用 vuex-persist (脯肉赛斯特)插件，它是为 Vuex 持久化储存而生的一个插件。不需要你手动存取 storage，而是直接将状态保存至 cookie 或者 localStorage中。
</code></pre></div><h3 id="_38-vuex-为什么要分模块并且加命名空间"><a href="#_38-vuex-为什么要分模块并且加命名空间" class="header-anchor">#</a> 38. Vuex 为什么要分模块并且加命名空间？</h3> <div class="language- extra-class"><pre><code>模块： 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能会变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。

命名空间： 默认情况下，模块内部的 action、mutation、getter是注册在全局命名空间的 --- 这样使得多个模块能够对同一 mutation 或 action 做出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced:true 的方式使其成为带命名的模块。当模块被注册后，他所有 getter、action、及 mutation 都会自动根据模块注册的路径调整命名。
</code></pre></div><h3 id="_39-使用过-vue-ssr-吗-说说-ssr"><a href="#_39-使用过-vue-ssr-吗-说说-ssr" class="header-anchor">#</a> 39. 使用过 Vue SSR 吗？说说 SSR</h3> <div class="language- extra-class"><pre><code>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。

优点：
 SSR 有着更好的 SEO、并且首屏加载速度更快。
 缺点：
 开发条件会受限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。
 服务器会有更大的负载需求。
</code></pre></div><h3 id="_40-vue-中使用了哪些设计模式"><a href="#_40-vue-中使用了哪些设计模式" class="header-anchor">#</a> 40. vue 中使用了哪些设计模式？</h3> <div class="language- extra-class"><pre><code>(1) 工厂模式 - 传入参数即可创建实例
 虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode。

(2) 单例模式 - 整个程序有且仅有一个实例
 vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉。

(3) 发布-订阅模式。（vue 事件机制）

(4) 观察者模式。（响应式数据原理）

(5) 装饰器模式（@装饰器的用法）

(6) 策略模式，策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现方案 - 比如选项的合并策略。
</code></pre></div><h3 id="_41-vue-set-方法原理"><a href="#_41-vue-set-方法原理" class="header-anchor">#</a> 41. Vue.set 方法原理</h3> <div class="language- extra-class"><pre><code>了解 Vue 响应式原理的同学都知道在两种情况下修改 Vue 是不会触发视图更新的。
 1、在实例创建之后添加新的属性到实例上（给响应式对象新增属性）
 2、直接更改数组下标来修改数组的值。

Vue.set 或者说是 $set 原理如下

因为响应式数据 我们给对象和数组本身新增了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪 然后会触发对象 __ob__ 的dep收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组。
</code></pre></div><h3 id="_42-vue-extend-作用和原理"><a href="#_42-vue-extend-作用和原理" class="header-anchor">#</a> 42. Vue.extend 作用和原理</h3> <div class="language- extra-class"><pre><code>官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

其实就是一个子类构造器，是Vue组件的核心api。实现思路就是使用原型继承的方法返回了 vue 的子类，并且利用 mergeOptions 把传入组件的 options 就和父类的 options 进行了合并。
</code></pre></div><h3 id="_43-写过自定义指令吗-原理是什么"><a href="#_43-写过自定义指令吗-原理是什么" class="header-anchor">#</a> 43. 写过自定义指令吗？原理是什么？</h3> <div class="language- extra-class"><pre><code>指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素添加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。

自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind

1、bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。

2、inserted：被绑定元素插入父节点时调用。

3、update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较前后的绑定值。

4、componentUpdated：被绑定元素所在模板完成一次更新周期时调用。

5、unbind：只调用一次，指令与元素解绑时调用。

原理：
 1、在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性
 2、通过 genDirectives 生成指令代码
 3、在 patch 前将指令的钩子提取到 cbs 中，在 patch 过程中调用对应的钩子。
 4、当执行指令对应钩子函数时，调用对应指令定义方法。
</code></pre></div><h3 id="_44-vue-模板编译原理"><a href="#_44-vue-模板编译原理" class="header-anchor">#</a> 44. Vue 模板编译原理</h3> <div class="language- extra-class"><pre><code>Vue 的编译过程就是将 template 转化为 render 函数的过程，分为以下三步：
 第一步是将 模板字符串转换成 element ASTs（解析器）
 第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）
 第三步是 使用element ASTs 生成 render 函数代码字符串（代码生成器）
</code></pre></div><h3 id="_45-生命周期钩子是如何实现的"><a href="#_45-生命周期钩子是如何实现的" class="header-anchor">#</a> 45. 生命周期钩子是如何实现的</h3> <div class="language- extra-class"><pre><code>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的生命周期钩子订阅好（内部采用数组的方法存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）
</code></pre></div><h3 id="_46-函数式组件使用场景和原理"><a href="#_46-函数式组件使用场景和原理" class="header-anchor">#</a> 46. 函数式组件使用场景和原理</h3> <div class="language- extra-class"><pre><code>函数式组件与普通组件的区别

1、函数式组件需要在声明组件时指定 functional:true

2、不需要实例化，所以没有this，this通过render函数的第二个参数context代替

3、没有生命周期钩子函数，不能使用计算属性，watch

4、不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件

5、因为函数组件时没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement

6、函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop，而普通的组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上（可以通过inheritAttrs属性禁止）

优点：1.由于函数组件不需要实例化，无状态，没有生命周期，所以渲染性要好于普通组件2.函数组件结构比较简单，代码结构更清晰

使用场景：

一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件。 “高阶组件”---用于接受一个组件为参数，返回一个被包装过的组件。
 相关代码如下：

```
if (isTrue(Ctor.options.functional)) { // 带有functional的属性的就是函数式组件
	return createFunctionalComponent(Ctor, propsData, data, context, children);
}
const listeners = data.on;
data.on = data.nativeOn;
installComponentHooks(data); // 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）
```
</code></pre></div><h3 id="_47-diff-算法了解吗"><a href="#_47-diff-算法了解吗" class="header-anchor">#</a> 47. diff 算法了解吗？</h3> <div class="language- extra-class"><pre><code>![img](file:///C:\Users\18225\AppData\Local\Temp\msohtmlclip1\01\clip_image004.jpg)

diff算法采用同级比较。

1、tag 标签不一致直接新节点替换旧节点。

2、tag 标签一样。

​	先替换属性

​	对比子元素

​	新老都有子元素，采用双指针方式进行对比
​	 sameVnode 判断tag和key完全相同为同一节点，进行节点复用
   头和头相等对比
   尾和尾相等对比
   头和尾相等对比

   sameVnode 的时候传入两个新老子节点patch(oldChild,newChild)
  乱序情况 -- 上面的都不符合，先遍历旧子节点数组形成 key值映射的map对象。
  然后根据新子节点数组循环 按照key值和位置关系移动以及新增节点 最后删除多余的旧子节点 如果移动旧节点同样需要    patch(oldChild,newChild)

 新的有子元素，老的没有子元素。-- 直接将子元素虚拟节点转化成真实节点插入即可。

 新的没有子元素，老的有子元素。 -- 直接清空 innerHtml

3、无 tag 标签 -- 文本节点直接比较内容是否一致
</code></pre></div><h3 id="_48-什么是双向绑定"><a href="#_48-什么是双向绑定" class="header-anchor">#</a> 48. 什么是双向绑定？</h3> <div class="language- extra-class"><pre><code>我们先从单向绑定切入

单向绑定非常简单，就是把 Model 绑定到 View，当我们用 JavaScript 代码更新 Model 时，View 就会自动更新

双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了 View，Model 的数据也自动被更新了，这种情况就是双向绑定

![img](file:///C:\Users\18225\AppData\Local\Temp\msohtmlclip1\01\clip_image005.png)

当用户填写表单时，View 的状态就被更新了，如果此时可以自动更新 Model 的状态，那就相当于我们把 Model 和 View 做了双向绑定

关系图如下

![img](file:///C:\Users\18225\AppData\Local\Temp\msohtmlclip1\01\clip_image006.png)
</code></pre></div><h3 id="_49-双向绑定的原理是什么"><a href="#_49-双向绑定的原理是什么" class="header-anchor">#</a> 49. 双向绑定的原理是什么？</h3> <div class="language- extra-class"><pre><code>我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成

数据层（Model）：应用的数据及业务逻辑

视图层（View）：应用的展示效果，各类 UI 组件

业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来

而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM

这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理

理解 ViewModel

它的主要职责就是：

数据变化后更新视图

视图变化后更新数据

当然，它还有两个主要部分组成

监听器（Observer）：对所有数据的属性进行监听

解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数
</code></pre></div><h3 id="_50-实现双向绑定"><a href="#_50-实现双向绑定" class="header-anchor">#</a> 50. 实现双向绑定</h3> <div class="language- extra-class"><pre><code>我们还是以 Vue 为例，先来看看 Vue 中的双向绑定流程是什么的

new Vue()首先执行初始化，对 data 执行响应化处理，这个过程发生 Observe 中；defineReactive 时为每⼀个 key 创建⼀个 Dep 实例

同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中；初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1

同时定义⼀个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数

由于 data 的某个 key 在⼀个视图中可能出现多次，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher;由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中

将来 data 中数据⼀旦发生变化,会首先找到对应的 Dep，通知所有 Watcher 执行更新函数；当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新

流程图如下：

![IMG_256](file:///C:\Users\18225\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg)

实现思路

defineReactive 时为每⼀个 key 创建⼀个 Dep 实例

初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1

由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中

当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新
</code></pre></div><h3 id="_51-route和-router-的区别"><a href="#_51-route和-router-的区别" class="header-anchor">#</a> 51. $route和$router 的区别</h3> <div class="language- extra-class"><pre><code> 答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等
</code></pre></div><h3 id="_52-跨域的方法"><a href="#_52-跨域的方法" class="header-anchor">#</a> 52. 跨域的方法：</h3> <div class="language- extra-class"><pre><code> 浏览器为了安全机制，采用同源策略，域名，协议，端口号一致的才可以进行访问;
 1，jsonp:是通过script标签的src属性来实现跨域的。通过src传过去一个函数，把数据放在函数的实参调用就可以拿到数据。由于是用src的链接，所以jsonp只支持get方式。content-type:javascript
 2，cors:改变请求头信息。客户端加：Origin:地址。服务器：Access-Control-Allow-Origin:地址.支持IE10以上。
 3，webpack:devServer里配置proxy:{api:'地址'};
 4，nginx反向代理：

```
nginx.conf
 upstream tomcatserver{
   server 192.168.72.49:8081//3.找到代理服务器的ip地址进行请求
 }
 server{
   listen    80;
   server_name  8081.max.com;//1.客户端调用名
   location / {
     proxy_pass  http://tomcatserver;//2.到代理服务器
     index  index.html index.html;
   }
 }
```
</code></pre></div><h3 id="_53-异步管理"><a href="#_53-异步管理" class="header-anchor">#</a> 53. 异步管理：</h3> <div class="language- extra-class"><pre><code> promise:promise等到执行完成后返回2种状态，resolve代表成功，reject代表失败。
 如果有多个异步可以用promise.all([]).
 async await:async声明一个函数返回一个promise。await等到promise异步执行结束拿到的一个结果
</code></pre></div><h3 id="_54-怎么定义-vue-router-的动态路由-怎么获取传过来的动态参数"><a href="#_54-怎么定义-vue-router-的动态路由-怎么获取传过来的动态参数" class="header-anchor">#</a> 54. 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数</h3> <div class="language- extra-class"><pre><code> 在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id

使用router对象的params.id。
</code></pre></div><h3 id="_55-vue-router-有哪几种导航钩子"><a href="#_55-vue-router-有哪几种导航钩子" class="header-anchor">#</a> 55. vue-router 有哪几种导航钩子？</h3> <div class="language- extra-class"><pre><code> 三种，

 第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
 第二种：组件内的钩子
 第三种：单独路由独享组件
</code></pre></div><h3 id="_56-scss-是什么-在-vue-cli-中的安装使用步骤是-有哪几大特性"><a href="#_56-scss-是什么-在-vue-cli-中的安装使用步骤是-有哪几大特性" class="header-anchor">#</a> 56. scss 是什么？在 vue.cli 中的安装使用步骤是？有哪几大特性？</h3> <div class="language- extra-class"><pre><code> css的预编译。

 使用步骤：

 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）

 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss

 第三步：还是在同一个文件，配置一个module属性

 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”

 有哪几大特性:

 1、可以用变量，例如（$变量名称=值）；
 2、可以用混合器，例如（）
 3、可以嵌套
</code></pre></div><h3 id="_57-vue-loader-是什么-使用它的用途有哪些"><a href="#_57-vue-loader-是什么-使用它的用途有哪些" class="header-anchor">#</a> 57. vue-loader 是什么？使用它的用途有哪些？</h3> <div class="language- extra-class"><pre><code> 解析.vue文件的一个加载器，跟template/js/style转换成js模块。

 用途：js可以写es6、style样式可以scss或less、template可以加jade等
</code></pre></div><h3 id="_58-vue-如何实现按需加载配合-webpack-设置"><a href="#_58-vue-如何实现按需加载配合-webpack-设置" class="header-anchor">#</a> 58. vue 如何实现按需加载配合 webpack 设置?</h3> <div class="language- extra-class"><pre><code> webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。
 不进行页面按需加载引入方式：import home from '../../common/home.vue'
 进行页面按需加载的引入方式：
 const home = r =&gt; require.ensure( [], () =&gt; r (require('../../common/home.vue')))
</code></pre></div><h3 id="_59-1-vuex-是什么-怎么使用-哪种功能场景使用它"><a href="#_59-1-vuex-是什么-怎么使用-哪种功能场景使用它" class="header-anchor">#</a> 59. （1）vuex 是什么？怎么使用？哪种功能场景使用它？</h3> <div class="language- extra-class"><pre><code> vue框架中状态管理。在main.js引入store，注入。新建一个目录store，…… export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
</code></pre></div><h3 id="_60-聊聊你对-vue-js-的-template-编译的理解"><a href="#_60-聊聊你对-vue-js-的-template-编译的理解" class="header-anchor">#</a> 60. 聊聊你对 Vue.js 的 template 编译的理解？</h3> <div class="language- extra-class"><pre><code> 答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
 详情步骤：
 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/bin/assets/js/app.b47fad0f.js" defer></script><script src="/bin/assets/js/2.22993a7e.js" defer></script><script src="/bin/assets/js/51.be01dce3.js" defer></script>
  </body>
</html>
